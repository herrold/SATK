#!/usr/bin/python3
# Copyright (C) 2014 Harold Grovesteen
#
# This file is part of SATK.
#
#     SATK is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     SATK is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with SATK.  If not, see <http://www.gnu.org/licenses/>.

# ASMA accepts single line, non-continued statements.  Many legacy programs are 
# structured as files of 80- or 72-byte card images.  This utility converts a file of 
# card images into a free-form file directly usable by ASMA.
#
# Each line of the input file is categorized as a
#   - card-image with continuation
#   - card-image without continuation
#   - free-form
#
# card-image statement fields are validated against the --fields argument
# 
# Output ASMA statements are constructed as follows:
#   card-image sequence field is removed from the card image.
#   If the card-image is continued, everything right of the last comma is removed
#   and the following card is added to the previous card.  The process continues
#   with each succeeding card.
#   Each card image becomes a comment in open code or a silent comment in macro
#   definitions.  Hence the input is preserved with comments, but not processed.
#   The generated ASMA statement will appear in the assembler listing after processing.
#   This has the potential to create exceedingly long lines in the assemler listing.

this_module="%s.py" % __name__
copyright="%s Copyright (C) %s Harold Grovesteen" % (this_module,"2014")

# Python imports:
import sys          # Access the system module for exiting and version information
if sys.hexversion<0x03030000:
    raise NotImplementedError("%s requires Python version 3.3 or higher, "
        "found: %s.%s" % (this_module,sys.version_info[0],sys.version_info[1]))
import argparse     # Access the command-line argument parser

# SATK imports: None
# ASMA imports: None
import asmcards     # Access the ascii input handler.

# Converts legacy mainframe assembler source files into ASMA single statement line
# files.  It converts legacy continued lines into a single line for ASMA and validates
# input files for expected structure.

class Cards(object):
    def __init__(self):
        self.messages=[]        # List of messages generated by convert() method

        # Generated ASMA statements
        self.asma_stmts=None

    def convert(self,images,debug=False):
        self.stats=Stats(len(images))
        good_lines=[]
        for lo in images:
            try:
                lo.validate()
            except asmcards.LineError as le:
                self.error("%s" % le)
                continue
            good_lines.append(lo)
        for gl in good_lines:
            gl.normal()
            if debug:
                print(gl.info())

    def error(self,msg):
        self.messages.append(msg)

class Stats(object):
    def __init__(self,stmts):
        self.stmts=stmts
        self.active=0
        self.comments=0
        self.empty=0
        self.in_error=0
        self.cont=0
        self.unrecognized=0
        self.ignored=0
        self.new=0
        self.Stmts=0
        self.ContStmts=0

    def count(self,stmt):
        if isinstance(stmt,Stmt):
            self.Stmts+=1
            if stmt.comment:
                self.comments+=1
            elif stmt.empty:
                self.empty+=1
            elif stmt.in_error:
                self.in_error+=1
            else:
                self.active+=1
            if stmt.ignore():
                self.ignored+=1
        elif isinsance(stmt,ContStmt):
            self.ContStmts+=1
            self.cont+=len(stmt.stmts)
        else:
            self.unrecognize+=1

    def report(self):
        total=self.ignored+self.active
        string=      "Input statements: %s" % self.stmts
        string=  "%s\nActive:           %s" % (string,self.active)
        string=  "%s\nContinued:        %s" % (string,self.cont)
        string=  "%s\nComments:         %s" % (string,self.comments)
        string=  "%s\nEmpty:            %s" % (string,self.empty)
        string=  "%s\nErrors:           %s" % (string,self.in_error)
        string=  "%s\nIgnored:          %s" % (string,self.ignored)
        string=  "%s\nProcessed:        %s" % (string,total)
        string=  "%s\nGenerated:        %s" % (string,self.new)
        string="%s\n\nStmt objects:     %s" % (string,self.Stmts)
        string=  "%s\nContStmt objects: %s" % (string,self.ContStmts)
        string=  "%s\nUnrecognized:     %s" % (string,self.unrecognized)
        return string

class Stmt(object):
    def __init__(self,line,ndx,fields=False):
        # These attributes are all determined independent of the input constraints
        self.raw=raw                 # Raw object of input text line
        self.line=raw.card           # Input source line of text
        self.length=raw.length       # Length of source text line
        self.lineno=raw.line         # Line number within input file

        # When any of these three attributes are set to True, the line will be ignored 
        self.empty=raw.empty         # True if line if of zero length
        self.in_error=False          # Set to True if the line generates an error
        self.comment=False           # True if a comment (loud or silend)

        self.silent=raw.silent       # True if a silent comment, False for loud
        self.continued=False         # Set by iscont() method when continued

        self.minimum=None

        # Attributes used to manage continued input statements.
        self.continued=False         # Set by iscont() method when continued
        self.continues=False         
        self.active=""               # Determined by iscont() method
        self.output=None
        
        # Type of continued statement
        # This statement is continued
        self.first=False
        # This statement both continues the previous statement and is itself continued
        self.middle=False
        # This continues the previous statement but is not itself continued
        self.last=False

        # Statement fields established by find_active() method
        self.name=None
        self.operation=None
        self.operands=None
        self.remarks=None            # Used for comments

        # This is the statement to be used for ASMA:
        self.asma_stmt=None

    def error(self,msg,cards):
        self.inerror=True
        m="[%s] %s" % (self.lineno,msg)
        cards.error(m)

    def find_fields(self,cards):
        cls=self.__class__.__name__
        cls_str="%s %s.find_fields() " % (this_module,cls)
        raise NotImplementedError("%s subclass %s must implement find_fields() method"\
            % (cls_str,cls))

    def ignore(self):
        return self.comment or self.in_error or self.empty

    def iscont(self,cont=None):
        if self.ignore():
            return
        if self.length>=72:
            char=self.line[71]       # This is the continuation column
        if cont is None:
            self.continued=char!=" "
        else:
            self.continued=char in cont

    def new(self,cards):
        cls=self.__class__.__name__
        cls_str="%s %s.new() " % (this_module,cls)
        raise NotImplementedError("%s subclass %s must implement new() method"\
            % (cls_str,cls))

class ContStmt(object):
    def __init__(self,stmts):
        if not isinstance(stmts,list):
            cls_str="%s %s.__init__() " % (this_module,self.__class__.__name__)
            raise ValueError("%s 'stmts' argument must be a list: %s" \
                % (cls_str,stmts))
        for n in range(len(stmts)):
            s=stmts[n]
            if not isinstance(s,Stmt):
                cls_str="%s %s.__init__() " % (this_module,self.__class__.__name__)
                raise ValueError("%s 'stmts' element not a Stmt object: %s" \
                    % (cls_str,n,s))
        if len(stmts)<2:
            cls_str="%s %s.__init__() " % (this_module,self.__class__.__name__)
            raise ValueError("%s 'stmts' argument must contain at lest two Stmt "
                "objects: %s" % (cls_str,len(stmts)))

        self.stmts=stmts   # List of Stmt objects constituting the continued statement

    def find_active(self):
        for s in self.stmts:
            s.find_active()

class FixedStmt(Stmt):
    def __init__(self,line,ndx,fields=False):
        super().__init__(line,ndx)

    def __str__(self):
        return "F-[%s] '%s'" % (self.lineno,self.line)

    def find_active(self,cards):
        if self.in_error:
            return
        if self.empty:
            self.error("empty statement prohibited",cards)
            return
        if self.comment and self.continued:
            self.error("comments statements may not be continued",cards)
            return

        # []  0 1 2 3 4 5 6 7 8  9 10 11 12 13 14 15 ...    70 71
        # col 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ...    71 72
        #    |<----name----->| |<--operation->|  |<-operands->| X

        if self.comment:
            self.remarks=self.line[:71].rstrip()
            return

        if self.line[8]!=" ":
            self.error("column 9 is not blank",cards)
            return
        if self.line[14]!=" ":
            self.error("column 15 is not blank",cards)
            return

        # Process name field
        name=self.line[0:8].rstrip()
        try:
            name.index(" ")
            msg="name field not left justified or contains space(s): '%s'" % name
            self.error(msg,cards)
        except ValueError:
            self.name=name

        # Process operation field
        operation=self.line[9:14].rstrip()
        if len(operation)==0:
            self.error("required operation field missing",cards)
        try:
            operation.index(" ")
            msg="operation field not left justified or contains space(s): '%s'" \
                % operation
            self.error(msg,cards)
        except ValueError:
            self.operation=operation

        self.operands=operands=self.line[15:71].rstrip()

    def new(self,cards):
        if self.in_error:
            return
        elif self.comment:
            self.asma_stmt=self.remarks
            return
        elif self.empty:
            asma_stmt=""
        else:
            if self.name is None:
                msg="name is None: %s" % self.line
                self.error(msg,cards)
                return
            name=self.name.ljust(8)
            if self.operation is None:
                msg="operation is None: %s" % self.line
                self.error(msg,cards)
                return
            operation=self.operation.ljust(5)
            if self.operands is None:
                msg="operands is None: %s" % self.line
                self.error(msg,cards)
                return
            asma_stmt="%s %s %s" % (name,operation,self.operands)
        self.asma_stmt=asma_stmt.rstrip()

    def test_length(self,cards):
        if self.ignore():
            return
        length=cards.size
        if length is not None and self.length!=length:
            msg="line length not %s: %s" % (length,self.length)
            self.error(msg,cards)

class Cards2ASMA(object):
    recfmt={"legacy":True,"stream":False}
    def __init__(self,args):
        self.args=args
        self.recfmt=Cards2ASMA.recfmt[args.recfmt]
        self.cont=args.cont
        self.size=args.size
        self.output=args.asma
        self.infile=args.source[0]
        self.macros=[]
        for m in args.macro:
            self.macros.append(m.upper())

        # Handles card input
        self.handler=asmcards.InputHandler()

        # Creates utility output
        self.util=Cards()

    def ioerror(self,action,ie):
        print("could not %s, %s (%s): %s" % (action,ie.strerror,ie.errno,ie.filename))
        sys.exit(1)

    # Returns the card images as a list of Raw objects.  Line termination characters
    # are removed from the string.
    def readcards(self):
        # Initialize the file read operation
        try:
            fo=open(self.infile,"r")
        except IOError as ie:
            self.ioerror("open for reading",ie)

        images=[]   # List of asmcards.Line objects
        self.handler.begin(legacy=self.recfmt,stream=self.cont,size=self.size)
        
        # Read the file and create asmcards.Line objects
        try:
            for line in fo.readlines():
                lineo=self.handler.text(line)
                if lineo is None:
                    continue
                images.append(lineo)
        except IOError as ie:
            self.ioerror("open read text file",ie)

        if not fo.closed:
            fo.close()

        # Reset handler
        self.handler.end()
        print("%s %s input lines: %s" % (this_module,self.infile,len(images)))
        return images

    def run(self,debug=False):
        images=self.readcards()   # Returns a list of asmcards.Line objects
        if len(images)==0:
            print("%s %s: no input lines to convert" % (this_module,self.legacy))
            sys.exit(1)

        #if debug:
        #    for lineo in images:
        #        for rawo in lineo.rawlines:
        #             print(rawo)
        
        asma_source=self.util.convert(images,debug=debug)
        messages=self.util.messages
        if len(messages)>0:
            for msg in messages:
                print(msg)
            return
        if asma_source is None:
            return
        print(asma_source)
        self.write_source(asma_source)

    def write_source(self,outfile):
        if self.output is None:
            return
        try:
            fo=open(self.output,"wt")
        except IOError as ie:
            self.ioerror("open for writing",ie)
        try:
            fo.write(outfile)
        except IOError as ie:
            self.ioerror("write",ie)
        try:
            fo.close()
        except IOError as ie:
            self.ioerror("close",ie)

def parse_args():
    parser=argparse.ArgumentParser(prog=this_module,
        epilog=copyright, 
        description="from a legacy card-image assembler source file create a "
            "ASMA free-form text file")

    # Source input file (Note: attribute source in the parser namespace will be a list)
    parser.add_argument("source",\
        help="input legacy card-image assembler source file path",nargs=1)

    parser.add_argument("-a","--asma",
        help="path to which generated ASMA source file is written")

    parser.add_argument("-c","--cont",default="\\",
        help="specify stream input continuation character(s) "
        "The default is the back-slash character: \\")

    parser.add_argument("-m","--macro",action="append",default=[],\
        help="identify a macro for alternate continuation handling")

    parser.add_argument("-r","--recfmt",choices=["legacy","stream"],default="legacy",
        help="input format: legacy content is in positions 1-72, stream "
        "allows content any positions.  Default is 'legacy'.")
    
    parser.add_argument("-s","--size",default=80,type=int,
        help="legacy input maximum record length.  Defaults to 80.")

    return parser.parse_args()

if __name__ == "__main__":
    util=Cards2ASMA(parse_args())
    print(copyright)
    util.run(debug=True)